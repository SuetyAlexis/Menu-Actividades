<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Luma en Onda Senoidal</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      display: grid;
      place-items: center;
      background-image: url('PlanetaF.jpg'); /* Imagen de fondo en tu carpeta */
      background-size: cover;
      background-position: center;
      font-family: Arial, sans-serif;
      color: #111;
    }

    .wrap {
      display: grid;
      gap: 12px;
      justify-items: center;
      padding: 16px;
    }

    .titulo {
      margin: 0;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0);
      font-weight: 700;
    }

    .canvas-box {
      display: grid;
      place-items: center;
      width: 80vw;
      max-width: 960px;
      aspect-ratio: 16 / 9;
      background: rgba(255,255,255,0.75);
      border-radius: 20px;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <h2 class="titulo">Parece que el Luma se está divirtiendo</h2>
    <div class="canvas-box">
      <canvas id="stage"></canvas>
    </div>
  </main>

  <script>
    // Rutas relativas locales
    const CENTER_IMAGE_URL = 'FondoPlaneta1.jpg'; // Fondo del canvas, ajustado al tamaño del canvas
    const LUMA_IMAGE_URL   = 'luma.png';          // Sprite que se mueve y describe una onda senoidal

    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');

    // ===== Canvas HiDPI responsivo =====
    function fitCanvasToBox() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width  = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Dibujamos en unidades CSS px
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('No se pudo cargar: ' + src));
      });
    }

    // ===== Parámetros del movimiento =====
    const params = {
      speedPxPerSec: 180, // velocidad horizontal en px/seg
      spriteWidthPx: 120, // ancho del Luma en px (constante)
      ampY: 60,           // amplitud vertical de la onda senoidal (px)
      wavelengthPx: 400   // longitud de onda horizontal (px)
    };

    let bgImg, lumaImg;

    // Estado del Luma
    const luma = {
      x: 0,
      y: 0,
      vx: params.speedPxPerSec, // hacia la derecha al iniciar
      w: 0,
      h: 0
    };

    let last = performance.now();

    function draw() {
      const now = performance.now();
      const dt = (now - last) / 1000; // en segundos
      last = now;

      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ===== Fondo del canvas ajustado al tamaño del canvas =====
      if (bgImg) {
        ctx.drawImage(bgImg, 0, 0, W, H);
      }

      // ===== Actualizar X y rebotar en bordes =====
      if (lumaImg) {
        const minX = luma.w / 2;
        const maxX = W - luma.w / 2;

        luma.x += luma.vx * dt;
        if (luma.x >= maxX) { luma.x = maxX; luma.vx *= -1; }
        else if (luma.x <= minX) { luma.x = minX; luma.vx *= -1; }

        // ===== Y como función senoidal de X =====
        const k = (Math.PI * 2) / params.wavelengthPx; // número de onda
        const midY = H * 0.5;
        luma.y = midY + params.ampY * Math.sin(k * (luma.x));

        // Dibujar Luma (sin cambios de escala)
        ctx.drawImage(lumaImg, luma.x - luma.w / 2, luma.y - luma.h / 2, luma.w, luma.h);
      }

      requestAnimationFrame(draw);
    }

    function placeLumaAtStart() {
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      luma.w = params.spriteWidthPx;
      luma.h = params.spriteWidthPx * (lumaImg.height / lumaImg.width);
      luma.x = luma.w / 2;      // inicia en el borde izquierdo
      luma.vx = Math.abs(luma.vx); // asegurar que arranca hacia la derecha
      const k = (Math.PI * 2) / params.wavelengthPx;
      luma.y = H * 0.5 + params.ampY * Math.sin(k * luma.x);
    }

    async function init() {
      fitCanvasToBox();
      window.addEventListener('resize', () => {
        fitCanvasToBox();
        if (lumaImg) placeLumaAtStart();
      });

      try {
        [bgImg, lumaImg] = await Promise.all([
          loadImage(CENTER_IMAGE_URL),
          loadImage(LUMA_IMAGE_URL)
        ]);
      } catch (err) {
        console.warn(err.message);
      }

      if (lumaImg) placeLumaAtStart();

      last = performance.now();
      requestAnimationFrame(draw);
    }

    init();
  </script>
</body>
</html>
